// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Map.proto

#ifndef PROTOBUF_Map_2eproto__INCLUDED
#define PROTOBUF_Map_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Common.pb.h"
// @@protoc_insertion_point(includes)

namespace qmyx {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Map_2eproto();
void protobuf_AssignDesc_Map_2eproto();
void protobuf_ShutdownFile_Map_2eproto();

class SPoint;
class SIdinfo;
class RIdList;
class SMapUpd;
class QMoveUpd;
class RMoveUpd;
class SViewRole;
class RViewRole;
class QCreateMap;
class RMapUpdateInfo;
class QChangeMap;
class SOtherRole;
class QOtherRole;
class ROtherRole;

enum VIEW {
  VIEW_ENTER = 1,
  VIEW_MOVE = 2,
  VIEW_LOGOUT = 3
};
bool VIEW_IsValid(int value);
const VIEW VIEW_MIN = VIEW_ENTER;
const VIEW VIEW_MAX = VIEW_LOGOUT;
const int VIEW_ARRAYSIZE = VIEW_MAX + 1;

const ::google::protobuf::EnumDescriptor* VIEW_descriptor();
inline const ::std::string& VIEW_Name(VIEW value) {
  return ::google::protobuf::internal::NameOfEnum(
    VIEW_descriptor(), value);
}
inline bool VIEW_Parse(
    const ::std::string& name, VIEW* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VIEW>(
    VIEW_descriptor(), name, value);
}
enum MAPTYPE {
  MAP_CITY = 0,
  MAP_FUBEN = 1,
  MAP_MUTILFUBEN = 2,
  MAP_ARENA = 3,
  MAP_WILED = 4
};
bool MAPTYPE_IsValid(int value);
const MAPTYPE MAPTYPE_MIN = MAP_CITY;
const MAPTYPE MAPTYPE_MAX = MAP_WILED;
const int MAPTYPE_ARRAYSIZE = MAPTYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MAPTYPE_descriptor();
inline const ::std::string& MAPTYPE_Name(MAPTYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MAPTYPE_descriptor(), value);
}
inline bool MAPTYPE_Parse(
    const ::std::string& name, MAPTYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MAPTYPE>(
    MAPTYPE_descriptor(), name, value);
}
enum OBJECTTYPE {
  TYPE_PLAYER = 1,
  TYPE_MONSTER = 2,
  TYPE_NPC = 3
};
bool OBJECTTYPE_IsValid(int value);
const OBJECTTYPE OBJECTTYPE_MIN = TYPE_PLAYER;
const OBJECTTYPE OBJECTTYPE_MAX = TYPE_NPC;
const int OBJECTTYPE_ARRAYSIZE = OBJECTTYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* OBJECTTYPE_descriptor();
inline const ::std::string& OBJECTTYPE_Name(OBJECTTYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    OBJECTTYPE_descriptor(), value);
}
inline bool OBJECTTYPE_Parse(
    const ::std::string& name, OBJECTTYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OBJECTTYPE>(
    OBJECTTYPE_descriptor(), name, value);
}
// ===================================================================

class SPoint : public ::google::protobuf::Message {
 public:
  SPoint();
  virtual ~SPoint();

  SPoint(const SPoint& from);

  inline SPoint& operator=(const SPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SPoint& default_instance();

  void Swap(SPoint* other);

  // implements Message ----------------------------------------------

  SPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SPoint& from);
  void MergeFrom(const SPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:qmyx.SPoint)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Map_2eproto();
  friend void protobuf_AssignDesc_Map_2eproto();
  friend void protobuf_ShutdownFile_Map_2eproto();

  void InitAsDefaultInstance();
  static SPoint* default_instance_;
};
// -------------------------------------------------------------------

class SIdinfo : public ::google::protobuf::Message {
 public:
  SIdinfo();
  virtual ~SIdinfo();

  SIdinfo(const SIdinfo& from);

  inline SIdinfo& operator=(const SIdinfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SIdinfo& default_instance();

  void Swap(SIdinfo* other);

  // implements Message ----------------------------------------------

  SIdinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SIdinfo& from);
  void MergeFrom(const SIdinfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 nId = 1;
  inline bool has_nid() const;
  inline void clear_nid();
  static const int kNIdFieldNumber = 1;
  inline ::google::protobuf::uint32 nid() const;
  inline void set_nid(::google::protobuf::uint32 value);

  // required uint32 nConfigId = 2;
  inline bool has_nconfigid() const;
  inline void clear_nconfigid();
  static const int kNConfigIdFieldNumber = 2;
  inline ::google::protobuf::uint32 nconfigid() const;
  inline void set_nconfigid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qmyx.SIdinfo)
 private:
  inline void set_has_nid();
  inline void clear_has_nid();
  inline void set_has_nconfigid();
  inline void clear_has_nconfigid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 nid_;
  ::google::protobuf::uint32 nconfigid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Map_2eproto();
  friend void protobuf_AssignDesc_Map_2eproto();
  friend void protobuf_ShutdownFile_Map_2eproto();

  void InitAsDefaultInstance();
  static SIdinfo* default_instance_;
};
// -------------------------------------------------------------------

class RIdList : public ::google::protobuf::Message {
 public:
  RIdList();
  virtual ~RIdList();

  RIdList(const RIdList& from);

  inline RIdList& operator=(const RIdList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RIdList& default_instance();

  void Swap(RIdList* other);

  // implements Message ----------------------------------------------

  RIdList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RIdList& from);
  void MergeFrom(const RIdList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .qmyx.SIdinfo Id_list = 1;
  inline int id_list_size() const;
  inline void clear_id_list();
  static const int kIdListFieldNumber = 1;
  inline const ::qmyx::SIdinfo& id_list(int index) const;
  inline ::qmyx::SIdinfo* mutable_id_list(int index);
  inline ::qmyx::SIdinfo* add_id_list();
  inline const ::google::protobuf::RepeatedPtrField< ::qmyx::SIdinfo >&
      id_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::qmyx::SIdinfo >*
      mutable_id_list();

  // @@protoc_insertion_point(class_scope:qmyx.RIdList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::qmyx::SIdinfo > id_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Map_2eproto();
  friend void protobuf_AssignDesc_Map_2eproto();
  friend void protobuf_ShutdownFile_Map_2eproto();

  void InitAsDefaultInstance();
  static RIdList* default_instance_;
};
// -------------------------------------------------------------------

class SMapUpd : public ::google::protobuf::Message {
 public:
  SMapUpd();
  virtual ~SMapUpd();

  SMapUpd(const SMapUpd& from);

  inline SMapUpd& operator=(const SMapUpd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SMapUpd& default_instance();

  void Swap(SMapUpd* other);

  // implements Message ----------------------------------------------

  SMapUpd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SMapUpd& from);
  void MergeFrom(const SMapUpd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 nid = 1;
  inline bool has_nid() const;
  inline void clear_nid();
  static const int kNidFieldNumber = 1;
  inline ::google::protobuf::uint32 nid() const;
  inline void set_nid(::google::protobuf::uint32 value);

  // required uint32 npid = 2;
  inline bool has_npid() const;
  inline void clear_npid();
  static const int kNpidFieldNumber = 2;
  inline ::google::protobuf::uint32 npid() const;
  inline void set_npid(::google::protobuf::uint32 value);

  // required uint32 nconfigid = 3;
  inline bool has_nconfigid() const;
  inline void clear_nconfigid();
  static const int kNconfigidFieldNumber = 3;
  inline ::google::protobuf::uint32 nconfigid() const;
  inline void set_nconfigid(::google::protobuf::uint32 value);

  // required .qmyx.SPoint pt = 4;
  inline bool has_pt() const;
  inline void clear_pt();
  static const int kPtFieldNumber = 4;
  inline const ::qmyx::SPoint& pt() const;
  inline ::qmyx::SPoint* mutable_pt();
  inline ::qmyx::SPoint* release_pt();
  inline void set_allocated_pt(::qmyx::SPoint* pt);

  // @@protoc_insertion_point(class_scope:qmyx.SMapUpd)
 private:
  inline void set_has_nid();
  inline void clear_has_nid();
  inline void set_has_npid();
  inline void clear_has_npid();
  inline void set_has_nconfigid();
  inline void clear_has_nconfigid();
  inline void set_has_pt();
  inline void clear_has_pt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 nid_;
  ::google::protobuf::uint32 npid_;
  ::qmyx::SPoint* pt_;
  ::google::protobuf::uint32 nconfigid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Map_2eproto();
  friend void protobuf_AssignDesc_Map_2eproto();
  friend void protobuf_ShutdownFile_Map_2eproto();

  void InitAsDefaultInstance();
  static SMapUpd* default_instance_;
};
// -------------------------------------------------------------------

class QMoveUpd : public ::google::protobuf::Message {
 public:
  QMoveUpd();
  virtual ~QMoveUpd();

  QMoveUpd(const QMoveUpd& from);

  inline QMoveUpd& operator=(const QMoveUpd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QMoveUpd& default_instance();

  void Swap(QMoveUpd* other);

  // implements Message ----------------------------------------------

  QMoveUpd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QMoveUpd& from);
  void MergeFrom(const QMoveUpd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 nid = 1;
  inline bool has_nid() const;
  inline void clear_nid();
  static const int kNidFieldNumber = 1;
  inline ::google::protobuf::uint32 nid() const;
  inline void set_nid(::google::protobuf::uint32 value);

  // required .qmyx.SPoint pt = 2;
  inline bool has_pt() const;
  inline void clear_pt();
  static const int kPtFieldNumber = 2;
  inline const ::qmyx::SPoint& pt() const;
  inline ::qmyx::SPoint* mutable_pt();
  inline ::qmyx::SPoint* release_pt();
  inline void set_allocated_pt(::qmyx::SPoint* pt);

  // optional uint32 trigger = 3;
  inline bool has_trigger() const;
  inline void clear_trigger();
  static const int kTriggerFieldNumber = 3;
  inline ::google::protobuf::uint32 trigger() const;
  inline void set_trigger(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qmyx.QMoveUpd)
 private:
  inline void set_has_nid();
  inline void clear_has_nid();
  inline void set_has_pt();
  inline void clear_has_pt();
  inline void set_has_trigger();
  inline void clear_has_trigger();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::qmyx::SPoint* pt_;
  ::google::protobuf::uint32 nid_;
  ::google::protobuf::uint32 trigger_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Map_2eproto();
  friend void protobuf_AssignDesc_Map_2eproto();
  friend void protobuf_ShutdownFile_Map_2eproto();

  void InitAsDefaultInstance();
  static QMoveUpd* default_instance_;
};
// -------------------------------------------------------------------

class RMoveUpd : public ::google::protobuf::Message {
 public:
  RMoveUpd();
  virtual ~RMoveUpd();

  RMoveUpd(const RMoveUpd& from);

  inline RMoveUpd& operator=(const RMoveUpd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RMoveUpd& default_instance();

  void Swap(RMoveUpd* other);

  // implements Message ----------------------------------------------

  RMoveUpd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RMoveUpd& from);
  void MergeFrom(const RMoveUpd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qmyx.RMoveUpd)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Map_2eproto();
  friend void protobuf_AssignDesc_Map_2eproto();
  friend void protobuf_ShutdownFile_Map_2eproto();

  void InitAsDefaultInstance();
  static RMoveUpd* default_instance_;
};
// -------------------------------------------------------------------

class SViewRole : public ::google::protobuf::Message {
 public:
  SViewRole();
  virtual ~SViewRole();

  SViewRole(const SViewRole& from);

  inline SViewRole& operator=(const SViewRole& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SViewRole& default_instance();

  void Swap(SViewRole* other);

  // implements Message ----------------------------------------------

  SViewRole* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SViewRole& from);
  void MergeFrom(const SViewRole& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 nid = 1;
  inline bool has_nid() const;
  inline void clear_nid();
  static const int kNidFieldNumber = 1;
  inline ::google::protobuf::uint32 nid() const;
  inline void set_nid(::google::protobuf::uint32 value);

  // required .qmyx.SPoint pt_start = 2;
  inline bool has_pt_start() const;
  inline void clear_pt_start();
  static const int kPtStartFieldNumber = 2;
  inline const ::qmyx::SPoint& pt_start() const;
  inline ::qmyx::SPoint* mutable_pt_start();
  inline ::qmyx::SPoint* release_pt_start();
  inline void set_allocated_pt_start(::qmyx::SPoint* pt_start);

  // required .qmyx.SPoint pt_end = 3;
  inline bool has_pt_end() const;
  inline void clear_pt_end();
  static const int kPtEndFieldNumber = 3;
  inline const ::qmyx::SPoint& pt_end() const;
  inline ::qmyx::SPoint* mutable_pt_end();
  inline ::qmyx::SPoint* release_pt_end();
  inline void set_allocated_pt_end(::qmyx::SPoint* pt_end);

  // @@protoc_insertion_point(class_scope:qmyx.SViewRole)
 private:
  inline void set_has_nid();
  inline void clear_has_nid();
  inline void set_has_pt_start();
  inline void clear_has_pt_start();
  inline void set_has_pt_end();
  inline void clear_has_pt_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::qmyx::SPoint* pt_start_;
  ::qmyx::SPoint* pt_end_;
  ::google::protobuf::uint32 nid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Map_2eproto();
  friend void protobuf_AssignDesc_Map_2eproto();
  friend void protobuf_ShutdownFile_Map_2eproto();

  void InitAsDefaultInstance();
  static SViewRole* default_instance_;
};
// -------------------------------------------------------------------

class RViewRole : public ::google::protobuf::Message {
 public:
  RViewRole();
  virtual ~RViewRole();

  RViewRole(const RViewRole& from);

  inline RViewRole& operator=(const RViewRole& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RViewRole& default_instance();

  void Swap(RViewRole* other);

  // implements Message ----------------------------------------------

  RViewRole* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RViewRole& from);
  void MergeFrom(const RViewRole& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .qmyx.VIEW type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::qmyx::VIEW type() const;
  inline void set_type(::qmyx::VIEW value);

  // repeated .qmyx.SViewRole info = 2;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::qmyx::SViewRole& info(int index) const;
  inline ::qmyx::SViewRole* mutable_info(int index);
  inline ::qmyx::SViewRole* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::qmyx::SViewRole >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::qmyx::SViewRole >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:qmyx.RViewRole)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::qmyx::SViewRole > info_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Map_2eproto();
  friend void protobuf_AssignDesc_Map_2eproto();
  friend void protobuf_ShutdownFile_Map_2eproto();

  void InitAsDefaultInstance();
  static RViewRole* default_instance_;
};
// -------------------------------------------------------------------

class QCreateMap : public ::google::protobuf::Message {
 public:
  QCreateMap();
  virtual ~QCreateMap();

  QCreateMap(const QCreateMap& from);

  inline QCreateMap& operator=(const QCreateMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QCreateMap& default_instance();

  void Swap(QCreateMap* other);

  // implements Message ----------------------------------------------

  QCreateMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QCreateMap& from);
  void MergeFrom(const QCreateMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 nsenceid = 1;
  inline bool has_nsenceid() const;
  inline void clear_nsenceid();
  static const int kNsenceidFieldNumber = 1;
  inline ::google::protobuf::uint32 nsenceid() const;
  inline void set_nsenceid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qmyx.QCreateMap)
 private:
  inline void set_has_nsenceid();
  inline void clear_has_nsenceid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 nsenceid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Map_2eproto();
  friend void protobuf_AssignDesc_Map_2eproto();
  friend void protobuf_ShutdownFile_Map_2eproto();

  void InitAsDefaultInstance();
  static QCreateMap* default_instance_;
};
// -------------------------------------------------------------------

class RMapUpdateInfo : public ::google::protobuf::Message {
 public:
  RMapUpdateInfo();
  virtual ~RMapUpdateInfo();

  RMapUpdateInfo(const RMapUpdateInfo& from);

  inline RMapUpdateInfo& operator=(const RMapUpdateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RMapUpdateInfo& default_instance();

  void Swap(RMapUpdateInfo* other);

  // implements Message ----------------------------------------------

  RMapUpdateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RMapUpdateInfo& from);
  void MergeFrom(const RMapUpdateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .qmyx.MAPTYPE type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::qmyx::MAPTYPE type() const;
  inline void set_type(::qmyx::MAPTYPE value);

  // required .qmyx.SMapUpd info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::qmyx::SMapUpd& info() const;
  inline ::qmyx::SMapUpd* mutable_info();
  inline ::qmyx::SMapUpd* release_info();
  inline void set_allocated_info(::qmyx::SMapUpd* info);

  // @@protoc_insertion_point(class_scope:qmyx.RMapUpdateInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::qmyx::SMapUpd* info_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Map_2eproto();
  friend void protobuf_AssignDesc_Map_2eproto();
  friend void protobuf_ShutdownFile_Map_2eproto();

  void InitAsDefaultInstance();
  static RMapUpdateInfo* default_instance_;
};
// -------------------------------------------------------------------

class QChangeMap : public ::google::protobuf::Message {
 public:
  QChangeMap();
  virtual ~QChangeMap();

  QChangeMap(const QChangeMap& from);

  inline QChangeMap& operator=(const QChangeMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QChangeMap& default_instance();

  void Swap(QChangeMap* other);

  // implements Message ----------------------------------------------

  QChangeMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QChangeMap& from);
  void MergeFrom(const QChangeMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 old_nid = 1;
  inline bool has_old_nid() const;
  inline void clear_old_nid();
  static const int kOldNidFieldNumber = 1;
  inline ::google::protobuf::uint32 old_nid() const;
  inline void set_old_nid(::google::protobuf::uint32 value);

  // required uint32 new_nid = 2;
  inline bool has_new_nid() const;
  inline void clear_new_nid();
  static const int kNewNidFieldNumber = 2;
  inline ::google::protobuf::uint32 new_nid() const;
  inline void set_new_nid(::google::protobuf::uint32 value);

  // required uint32 nid = 3;
  inline bool has_nid() const;
  inline void clear_nid();
  static const int kNidFieldNumber = 3;
  inline ::google::protobuf::uint32 nid() const;
  inline void set_nid(::google::protobuf::uint32 value);

  // required .qmyx.SPoint pt_born = 4;
  inline bool has_pt_born() const;
  inline void clear_pt_born();
  static const int kPtBornFieldNumber = 4;
  inline const ::qmyx::SPoint& pt_born() const;
  inline ::qmyx::SPoint* mutable_pt_born();
  inline ::qmyx::SPoint* release_pt_born();
  inline void set_allocated_pt_born(::qmyx::SPoint* pt_born);

  // @@protoc_insertion_point(class_scope:qmyx.QChangeMap)
 private:
  inline void set_has_old_nid();
  inline void clear_has_old_nid();
  inline void set_has_new_nid();
  inline void clear_has_new_nid();
  inline void set_has_nid();
  inline void clear_has_nid();
  inline void set_has_pt_born();
  inline void clear_has_pt_born();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 old_nid_;
  ::google::protobuf::uint32 new_nid_;
  ::qmyx::SPoint* pt_born_;
  ::google::protobuf::uint32 nid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Map_2eproto();
  friend void protobuf_AssignDesc_Map_2eproto();
  friend void protobuf_ShutdownFile_Map_2eproto();

  void InitAsDefaultInstance();
  static QChangeMap* default_instance_;
};
// -------------------------------------------------------------------

class SOtherRole : public ::google::protobuf::Message {
 public:
  SOtherRole();
  virtual ~SOtherRole();

  SOtherRole(const SOtherRole& from);

  inline SOtherRole& operator=(const SOtherRole& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SOtherRole& default_instance();

  void Swap(SOtherRole* other);

  // implements Message ----------------------------------------------

  SOtherRole* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SOtherRole& from);
  void MergeFrom(const SOtherRole& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 nid = 1;
  inline bool has_nid() const;
  inline void clear_nid();
  static const int kNidFieldNumber = 1;
  inline ::google::protobuf::uint32 nid() const;
  inline void set_nid(::google::protobuf::uint32 value);

  // required .qmyx.OBJECTTYPE ntype = 2;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNtypeFieldNumber = 2;
  inline ::qmyx::OBJECTTYPE ntype() const;
  inline void set_ntype(::qmyx::OBJECTTYPE value);

  // required uint32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint32 nconfigid = 4;
  inline bool has_nconfigid() const;
  inline void clear_nconfigid();
  static const int kNconfigidFieldNumber = 4;
  inline ::google::protobuf::uint32 nconfigid() const;
  inline void set_nconfigid(::google::protobuf::uint32 value);

  // required uint32 model = 5;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 5;
  inline ::google::protobuf::uint32 model() const;
  inline void set_model(::google::protobuf::uint32 value);

  // required uint32 gender = 6;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 6;
  inline ::google::protobuf::uint32 gender() const;
  inline void set_gender(::google::protobuf::uint32 value);

  // required uint32 job = 7;
  inline bool has_job() const;
  inline void clear_job();
  static const int kJobFieldNumber = 7;
  inline ::google::protobuf::uint32 job() const;
  inline void set_job(::google::protobuf::uint32 value);

  // required string name = 8;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 8;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:qmyx.SOtherRole)
 private:
  inline void set_has_nid();
  inline void clear_has_nid();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_nconfigid();
  inline void clear_has_nconfigid();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 nid_;
  int ntype_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 nconfigid_;
  ::google::protobuf::uint32 model_;
  ::google::protobuf::uint32 gender_;
  ::std::string* name_;
  ::google::protobuf::uint32 job_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_Map_2eproto();
  friend void protobuf_AssignDesc_Map_2eproto();
  friend void protobuf_ShutdownFile_Map_2eproto();

  void InitAsDefaultInstance();
  static SOtherRole* default_instance_;
};
// -------------------------------------------------------------------

class QOtherRole : public ::google::protobuf::Message {
 public:
  QOtherRole();
  virtual ~QOtherRole();

  QOtherRole(const QOtherRole& from);

  inline QOtherRole& operator=(const QOtherRole& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QOtherRole& default_instance();

  void Swap(QOtherRole* other);

  // implements Message ----------------------------------------------

  QOtherRole* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QOtherRole& from);
  void MergeFrom(const QOtherRole& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 otherrid = 1;
  inline int otherrid_size() const;
  inline void clear_otherrid();
  static const int kOtherridFieldNumber = 1;
  inline ::google::protobuf::uint32 otherrid(int index) const;
  inline void set_otherrid(int index, ::google::protobuf::uint32 value);
  inline void add_otherrid(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      otherrid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_otherrid();

  // @@protoc_insertion_point(class_scope:qmyx.QOtherRole)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > otherrid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Map_2eproto();
  friend void protobuf_AssignDesc_Map_2eproto();
  friend void protobuf_ShutdownFile_Map_2eproto();

  void InitAsDefaultInstance();
  static QOtherRole* default_instance_;
};
// -------------------------------------------------------------------

class ROtherRole : public ::google::protobuf::Message {
 public:
  ROtherRole();
  virtual ~ROtherRole();

  ROtherRole(const ROtherRole& from);

  inline ROtherRole& operator=(const ROtherRole& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ROtherRole& default_instance();

  void Swap(ROtherRole* other);

  // implements Message ----------------------------------------------

  ROtherRole* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ROtherRole& from);
  void MergeFrom(const ROtherRole& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .qmyx.SOtherRole other = 1;
  inline int other_size() const;
  inline void clear_other();
  static const int kOtherFieldNumber = 1;
  inline const ::qmyx::SOtherRole& other(int index) const;
  inline ::qmyx::SOtherRole* mutable_other(int index);
  inline ::qmyx::SOtherRole* add_other();
  inline const ::google::protobuf::RepeatedPtrField< ::qmyx::SOtherRole >&
      other() const;
  inline ::google::protobuf::RepeatedPtrField< ::qmyx::SOtherRole >*
      mutable_other();

  // @@protoc_insertion_point(class_scope:qmyx.ROtherRole)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::qmyx::SOtherRole > other_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Map_2eproto();
  friend void protobuf_AssignDesc_Map_2eproto();
  friend void protobuf_ShutdownFile_Map_2eproto();

  void InitAsDefaultInstance();
  static ROtherRole* default_instance_;
};
// ===================================================================


// ===================================================================

// SPoint

// required int32 x = 1;
inline bool SPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SPoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SPoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 SPoint::x() const {
  return x_;
}
inline void SPoint::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool SPoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SPoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SPoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SPoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 SPoint::y() const {
  return y_;
}
inline void SPoint::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// SIdinfo

// required uint32 nId = 1;
inline bool SIdinfo::has_nid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SIdinfo::set_has_nid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SIdinfo::clear_has_nid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SIdinfo::clear_nid() {
  nid_ = 0u;
  clear_has_nid();
}
inline ::google::protobuf::uint32 SIdinfo::nid() const {
  return nid_;
}
inline void SIdinfo::set_nid(::google::protobuf::uint32 value) {
  set_has_nid();
  nid_ = value;
}

// required uint32 nConfigId = 2;
inline bool SIdinfo::has_nconfigid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SIdinfo::set_has_nconfigid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SIdinfo::clear_has_nconfigid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SIdinfo::clear_nconfigid() {
  nconfigid_ = 0u;
  clear_has_nconfigid();
}
inline ::google::protobuf::uint32 SIdinfo::nconfigid() const {
  return nconfigid_;
}
inline void SIdinfo::set_nconfigid(::google::protobuf::uint32 value) {
  set_has_nconfigid();
  nconfigid_ = value;
}

// -------------------------------------------------------------------

// RIdList

// repeated .qmyx.SIdinfo Id_list = 1;
inline int RIdList::id_list_size() const {
  return id_list_.size();
}
inline void RIdList::clear_id_list() {
  id_list_.Clear();
}
inline const ::qmyx::SIdinfo& RIdList::id_list(int index) const {
  return id_list_.Get(index);
}
inline ::qmyx::SIdinfo* RIdList::mutable_id_list(int index) {
  return id_list_.Mutable(index);
}
inline ::qmyx::SIdinfo* RIdList::add_id_list() {
  return id_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::qmyx::SIdinfo >&
RIdList::id_list() const {
  return id_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::qmyx::SIdinfo >*
RIdList::mutable_id_list() {
  return &id_list_;
}

// -------------------------------------------------------------------

// SMapUpd

// required uint32 nid = 1;
inline bool SMapUpd::has_nid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SMapUpd::set_has_nid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SMapUpd::clear_has_nid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SMapUpd::clear_nid() {
  nid_ = 0u;
  clear_has_nid();
}
inline ::google::protobuf::uint32 SMapUpd::nid() const {
  return nid_;
}
inline void SMapUpd::set_nid(::google::protobuf::uint32 value) {
  set_has_nid();
  nid_ = value;
}

// required uint32 npid = 2;
inline bool SMapUpd::has_npid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SMapUpd::set_has_npid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SMapUpd::clear_has_npid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SMapUpd::clear_npid() {
  npid_ = 0u;
  clear_has_npid();
}
inline ::google::protobuf::uint32 SMapUpd::npid() const {
  return npid_;
}
inline void SMapUpd::set_npid(::google::protobuf::uint32 value) {
  set_has_npid();
  npid_ = value;
}

// required uint32 nconfigid = 3;
inline bool SMapUpd::has_nconfigid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SMapUpd::set_has_nconfigid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SMapUpd::clear_has_nconfigid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SMapUpd::clear_nconfigid() {
  nconfigid_ = 0u;
  clear_has_nconfigid();
}
inline ::google::protobuf::uint32 SMapUpd::nconfigid() const {
  return nconfigid_;
}
inline void SMapUpd::set_nconfigid(::google::protobuf::uint32 value) {
  set_has_nconfigid();
  nconfigid_ = value;
}

// required .qmyx.SPoint pt = 4;
inline bool SMapUpd::has_pt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SMapUpd::set_has_pt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SMapUpd::clear_has_pt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SMapUpd::clear_pt() {
  if (pt_ != NULL) pt_->::qmyx::SPoint::Clear();
  clear_has_pt();
}
inline const ::qmyx::SPoint& SMapUpd::pt() const {
  return pt_ != NULL ? *pt_ : *default_instance_->pt_;
}
inline ::qmyx::SPoint* SMapUpd::mutable_pt() {
  set_has_pt();
  if (pt_ == NULL) pt_ = new ::qmyx::SPoint;
  return pt_;
}
inline ::qmyx::SPoint* SMapUpd::release_pt() {
  clear_has_pt();
  ::qmyx::SPoint* temp = pt_;
  pt_ = NULL;
  return temp;
}
inline void SMapUpd::set_allocated_pt(::qmyx::SPoint* pt) {
  delete pt_;
  pt_ = pt;
  if (pt) {
    set_has_pt();
  } else {
    clear_has_pt();
  }
}

// -------------------------------------------------------------------

// QMoveUpd

// required uint32 nid = 1;
inline bool QMoveUpd::has_nid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QMoveUpd::set_has_nid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QMoveUpd::clear_has_nid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QMoveUpd::clear_nid() {
  nid_ = 0u;
  clear_has_nid();
}
inline ::google::protobuf::uint32 QMoveUpd::nid() const {
  return nid_;
}
inline void QMoveUpd::set_nid(::google::protobuf::uint32 value) {
  set_has_nid();
  nid_ = value;
}

// required .qmyx.SPoint pt = 2;
inline bool QMoveUpd::has_pt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QMoveUpd::set_has_pt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QMoveUpd::clear_has_pt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QMoveUpd::clear_pt() {
  if (pt_ != NULL) pt_->::qmyx::SPoint::Clear();
  clear_has_pt();
}
inline const ::qmyx::SPoint& QMoveUpd::pt() const {
  return pt_ != NULL ? *pt_ : *default_instance_->pt_;
}
inline ::qmyx::SPoint* QMoveUpd::mutable_pt() {
  set_has_pt();
  if (pt_ == NULL) pt_ = new ::qmyx::SPoint;
  return pt_;
}
inline ::qmyx::SPoint* QMoveUpd::release_pt() {
  clear_has_pt();
  ::qmyx::SPoint* temp = pt_;
  pt_ = NULL;
  return temp;
}
inline void QMoveUpd::set_allocated_pt(::qmyx::SPoint* pt) {
  delete pt_;
  pt_ = pt;
  if (pt) {
    set_has_pt();
  } else {
    clear_has_pt();
  }
}

// optional uint32 trigger = 3;
inline bool QMoveUpd::has_trigger() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QMoveUpd::set_has_trigger() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QMoveUpd::clear_has_trigger() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QMoveUpd::clear_trigger() {
  trigger_ = 0u;
  clear_has_trigger();
}
inline ::google::protobuf::uint32 QMoveUpd::trigger() const {
  return trigger_;
}
inline void QMoveUpd::set_trigger(::google::protobuf::uint32 value) {
  set_has_trigger();
  trigger_ = value;
}

// -------------------------------------------------------------------

// RMoveUpd

// required uint32 result = 1;
inline bool RMoveUpd::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RMoveUpd::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RMoveUpd::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RMoveUpd::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 RMoveUpd::result() const {
  return result_;
}
inline void RMoveUpd::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// SViewRole

// required uint32 nid = 1;
inline bool SViewRole::has_nid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SViewRole::set_has_nid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SViewRole::clear_has_nid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SViewRole::clear_nid() {
  nid_ = 0u;
  clear_has_nid();
}
inline ::google::protobuf::uint32 SViewRole::nid() const {
  return nid_;
}
inline void SViewRole::set_nid(::google::protobuf::uint32 value) {
  set_has_nid();
  nid_ = value;
}

// required .qmyx.SPoint pt_start = 2;
inline bool SViewRole::has_pt_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SViewRole::set_has_pt_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SViewRole::clear_has_pt_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SViewRole::clear_pt_start() {
  if (pt_start_ != NULL) pt_start_->::qmyx::SPoint::Clear();
  clear_has_pt_start();
}
inline const ::qmyx::SPoint& SViewRole::pt_start() const {
  return pt_start_ != NULL ? *pt_start_ : *default_instance_->pt_start_;
}
inline ::qmyx::SPoint* SViewRole::mutable_pt_start() {
  set_has_pt_start();
  if (pt_start_ == NULL) pt_start_ = new ::qmyx::SPoint;
  return pt_start_;
}
inline ::qmyx::SPoint* SViewRole::release_pt_start() {
  clear_has_pt_start();
  ::qmyx::SPoint* temp = pt_start_;
  pt_start_ = NULL;
  return temp;
}
inline void SViewRole::set_allocated_pt_start(::qmyx::SPoint* pt_start) {
  delete pt_start_;
  pt_start_ = pt_start;
  if (pt_start) {
    set_has_pt_start();
  } else {
    clear_has_pt_start();
  }
}

// required .qmyx.SPoint pt_end = 3;
inline bool SViewRole::has_pt_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SViewRole::set_has_pt_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SViewRole::clear_has_pt_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SViewRole::clear_pt_end() {
  if (pt_end_ != NULL) pt_end_->::qmyx::SPoint::Clear();
  clear_has_pt_end();
}
inline const ::qmyx::SPoint& SViewRole::pt_end() const {
  return pt_end_ != NULL ? *pt_end_ : *default_instance_->pt_end_;
}
inline ::qmyx::SPoint* SViewRole::mutable_pt_end() {
  set_has_pt_end();
  if (pt_end_ == NULL) pt_end_ = new ::qmyx::SPoint;
  return pt_end_;
}
inline ::qmyx::SPoint* SViewRole::release_pt_end() {
  clear_has_pt_end();
  ::qmyx::SPoint* temp = pt_end_;
  pt_end_ = NULL;
  return temp;
}
inline void SViewRole::set_allocated_pt_end(::qmyx::SPoint* pt_end) {
  delete pt_end_;
  pt_end_ = pt_end;
  if (pt_end) {
    set_has_pt_end();
  } else {
    clear_has_pt_end();
  }
}

// -------------------------------------------------------------------

// RViewRole

// required .qmyx.VIEW type = 1;
inline bool RViewRole::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RViewRole::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RViewRole::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RViewRole::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::qmyx::VIEW RViewRole::type() const {
  return static_cast< ::qmyx::VIEW >(type_);
}
inline void RViewRole::set_type(::qmyx::VIEW value) {
  assert(::qmyx::VIEW_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .qmyx.SViewRole info = 2;
inline int RViewRole::info_size() const {
  return info_.size();
}
inline void RViewRole::clear_info() {
  info_.Clear();
}
inline const ::qmyx::SViewRole& RViewRole::info(int index) const {
  return info_.Get(index);
}
inline ::qmyx::SViewRole* RViewRole::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::qmyx::SViewRole* RViewRole::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::qmyx::SViewRole >&
RViewRole::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::qmyx::SViewRole >*
RViewRole::mutable_info() {
  return &info_;
}

// -------------------------------------------------------------------

// QCreateMap

// required uint32 nsenceid = 1;
inline bool QCreateMap::has_nsenceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QCreateMap::set_has_nsenceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QCreateMap::clear_has_nsenceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QCreateMap::clear_nsenceid() {
  nsenceid_ = 0u;
  clear_has_nsenceid();
}
inline ::google::protobuf::uint32 QCreateMap::nsenceid() const {
  return nsenceid_;
}
inline void QCreateMap::set_nsenceid(::google::protobuf::uint32 value) {
  set_has_nsenceid();
  nsenceid_ = value;
}

// -------------------------------------------------------------------

// RMapUpdateInfo

// required .qmyx.MAPTYPE type = 1;
inline bool RMapUpdateInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RMapUpdateInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RMapUpdateInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RMapUpdateInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::qmyx::MAPTYPE RMapUpdateInfo::type() const {
  return static_cast< ::qmyx::MAPTYPE >(type_);
}
inline void RMapUpdateInfo::set_type(::qmyx::MAPTYPE value) {
  assert(::qmyx::MAPTYPE_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .qmyx.SMapUpd info = 2;
inline bool RMapUpdateInfo::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RMapUpdateInfo::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RMapUpdateInfo::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RMapUpdateInfo::clear_info() {
  if (info_ != NULL) info_->::qmyx::SMapUpd::Clear();
  clear_has_info();
}
inline const ::qmyx::SMapUpd& RMapUpdateInfo::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::qmyx::SMapUpd* RMapUpdateInfo::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::qmyx::SMapUpd;
  return info_;
}
inline ::qmyx::SMapUpd* RMapUpdateInfo::release_info() {
  clear_has_info();
  ::qmyx::SMapUpd* temp = info_;
  info_ = NULL;
  return temp;
}
inline void RMapUpdateInfo::set_allocated_info(::qmyx::SMapUpd* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// QChangeMap

// required uint32 old_nid = 1;
inline bool QChangeMap::has_old_nid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QChangeMap::set_has_old_nid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QChangeMap::clear_has_old_nid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QChangeMap::clear_old_nid() {
  old_nid_ = 0u;
  clear_has_old_nid();
}
inline ::google::protobuf::uint32 QChangeMap::old_nid() const {
  return old_nid_;
}
inline void QChangeMap::set_old_nid(::google::protobuf::uint32 value) {
  set_has_old_nid();
  old_nid_ = value;
}

// required uint32 new_nid = 2;
inline bool QChangeMap::has_new_nid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QChangeMap::set_has_new_nid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QChangeMap::clear_has_new_nid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QChangeMap::clear_new_nid() {
  new_nid_ = 0u;
  clear_has_new_nid();
}
inline ::google::protobuf::uint32 QChangeMap::new_nid() const {
  return new_nid_;
}
inline void QChangeMap::set_new_nid(::google::protobuf::uint32 value) {
  set_has_new_nid();
  new_nid_ = value;
}

// required uint32 nid = 3;
inline bool QChangeMap::has_nid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QChangeMap::set_has_nid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QChangeMap::clear_has_nid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QChangeMap::clear_nid() {
  nid_ = 0u;
  clear_has_nid();
}
inline ::google::protobuf::uint32 QChangeMap::nid() const {
  return nid_;
}
inline void QChangeMap::set_nid(::google::protobuf::uint32 value) {
  set_has_nid();
  nid_ = value;
}

// required .qmyx.SPoint pt_born = 4;
inline bool QChangeMap::has_pt_born() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QChangeMap::set_has_pt_born() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QChangeMap::clear_has_pt_born() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QChangeMap::clear_pt_born() {
  if (pt_born_ != NULL) pt_born_->::qmyx::SPoint::Clear();
  clear_has_pt_born();
}
inline const ::qmyx::SPoint& QChangeMap::pt_born() const {
  return pt_born_ != NULL ? *pt_born_ : *default_instance_->pt_born_;
}
inline ::qmyx::SPoint* QChangeMap::mutable_pt_born() {
  set_has_pt_born();
  if (pt_born_ == NULL) pt_born_ = new ::qmyx::SPoint;
  return pt_born_;
}
inline ::qmyx::SPoint* QChangeMap::release_pt_born() {
  clear_has_pt_born();
  ::qmyx::SPoint* temp = pt_born_;
  pt_born_ = NULL;
  return temp;
}
inline void QChangeMap::set_allocated_pt_born(::qmyx::SPoint* pt_born) {
  delete pt_born_;
  pt_born_ = pt_born;
  if (pt_born) {
    set_has_pt_born();
  } else {
    clear_has_pt_born();
  }
}

// -------------------------------------------------------------------

// SOtherRole

// required uint32 nid = 1;
inline bool SOtherRole::has_nid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SOtherRole::set_has_nid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SOtherRole::clear_has_nid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SOtherRole::clear_nid() {
  nid_ = 0u;
  clear_has_nid();
}
inline ::google::protobuf::uint32 SOtherRole::nid() const {
  return nid_;
}
inline void SOtherRole::set_nid(::google::protobuf::uint32 value) {
  set_has_nid();
  nid_ = value;
}

// required .qmyx.OBJECTTYPE ntype = 2;
inline bool SOtherRole::has_ntype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SOtherRole::set_has_ntype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SOtherRole::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SOtherRole::clear_ntype() {
  ntype_ = 1;
  clear_has_ntype();
}
inline ::qmyx::OBJECTTYPE SOtherRole::ntype() const {
  return static_cast< ::qmyx::OBJECTTYPE >(ntype_);
}
inline void SOtherRole::set_ntype(::qmyx::OBJECTTYPE value) {
  assert(::qmyx::OBJECTTYPE_IsValid(value));
  set_has_ntype();
  ntype_ = value;
}

// required uint32 level = 3;
inline bool SOtherRole::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SOtherRole::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SOtherRole::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SOtherRole::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 SOtherRole::level() const {
  return level_;
}
inline void SOtherRole::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required uint32 nconfigid = 4;
inline bool SOtherRole::has_nconfigid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SOtherRole::set_has_nconfigid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SOtherRole::clear_has_nconfigid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SOtherRole::clear_nconfigid() {
  nconfigid_ = 0u;
  clear_has_nconfigid();
}
inline ::google::protobuf::uint32 SOtherRole::nconfigid() const {
  return nconfigid_;
}
inline void SOtherRole::set_nconfigid(::google::protobuf::uint32 value) {
  set_has_nconfigid();
  nconfigid_ = value;
}

// required uint32 model = 5;
inline bool SOtherRole::has_model() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SOtherRole::set_has_model() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SOtherRole::clear_has_model() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SOtherRole::clear_model() {
  model_ = 0u;
  clear_has_model();
}
inline ::google::protobuf::uint32 SOtherRole::model() const {
  return model_;
}
inline void SOtherRole::set_model(::google::protobuf::uint32 value) {
  set_has_model();
  model_ = value;
}

// required uint32 gender = 6;
inline bool SOtherRole::has_gender() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SOtherRole::set_has_gender() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SOtherRole::clear_has_gender() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SOtherRole::clear_gender() {
  gender_ = 0u;
  clear_has_gender();
}
inline ::google::protobuf::uint32 SOtherRole::gender() const {
  return gender_;
}
inline void SOtherRole::set_gender(::google::protobuf::uint32 value) {
  set_has_gender();
  gender_ = value;
}

// required uint32 job = 7;
inline bool SOtherRole::has_job() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SOtherRole::set_has_job() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SOtherRole::clear_has_job() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SOtherRole::clear_job() {
  job_ = 0u;
  clear_has_job();
}
inline ::google::protobuf::uint32 SOtherRole::job() const {
  return job_;
}
inline void SOtherRole::set_job(::google::protobuf::uint32 value) {
  set_has_job();
  job_ = value;
}

// required string name = 8;
inline bool SOtherRole::has_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SOtherRole::set_has_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SOtherRole::clear_has_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SOtherRole::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SOtherRole::name() const {
  return *name_;
}
inline void SOtherRole::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SOtherRole::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SOtherRole::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SOtherRole::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SOtherRole::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SOtherRole::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// QOtherRole

// repeated uint32 otherrid = 1;
inline int QOtherRole::otherrid_size() const {
  return otherrid_.size();
}
inline void QOtherRole::clear_otherrid() {
  otherrid_.Clear();
}
inline ::google::protobuf::uint32 QOtherRole::otherrid(int index) const {
  return otherrid_.Get(index);
}
inline void QOtherRole::set_otherrid(int index, ::google::protobuf::uint32 value) {
  otherrid_.Set(index, value);
}
inline void QOtherRole::add_otherrid(::google::protobuf::uint32 value) {
  otherrid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
QOtherRole::otherrid() const {
  return otherrid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
QOtherRole::mutable_otherrid() {
  return &otherrid_;
}

// -------------------------------------------------------------------

// ROtherRole

// repeated .qmyx.SOtherRole other = 1;
inline int ROtherRole::other_size() const {
  return other_.size();
}
inline void ROtherRole::clear_other() {
  other_.Clear();
}
inline const ::qmyx::SOtherRole& ROtherRole::other(int index) const {
  return other_.Get(index);
}
inline ::qmyx::SOtherRole* ROtherRole::mutable_other(int index) {
  return other_.Mutable(index);
}
inline ::qmyx::SOtherRole* ROtherRole::add_other() {
  return other_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::qmyx::SOtherRole >&
ROtherRole::other() const {
  return other_;
}
inline ::google::protobuf::RepeatedPtrField< ::qmyx::SOtherRole >*
ROtherRole::mutable_other() {
  return &other_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace qmyx

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::qmyx::VIEW>() {
  return ::qmyx::VIEW_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::qmyx::MAPTYPE>() {
  return ::qmyx::MAPTYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::qmyx::OBJECTTYPE>() {
  return ::qmyx::OBJECTTYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Map_2eproto__INCLUDED
